import { supabase } from '@/integrations/supabase/client';
import { Order, CartItem } from '@/types';

interface CreateOrderData {
  userId: string | null;
  items: CartItem[];
  shippingAddress: {
    name: string;
    phone: string;
    address: string;
  };
  paymentMethod: 'cod' | 'stripe';
}

export const createOrder = async (orderData: CreateOrderData): Promise<Order> => {
  const subtotal = orderData.items.reduce(
    (sum, item) => sum + item.product.price * item.quantity,
    0
  );
  const shippingCost = subtotal >= 2000 ? 0 : 100;
  const total = subtotal + shippingCost;

  // Create order
  const { data: order, error: orderError } = await supabase
    .from('orders')
    .insert({
      user_id: orderData.userId,
      order_number: '', // Will be auto-generated by trigger
      status: 'pending',
      payment_method: orderData.paymentMethod,
      payment_status: 'pending',
      subtotal: subtotal,
      shipping_cost: shippingCost,
      discount: 0,
      total: total,
      shipping_name: orderData.shippingAddress.name,
      shipping_phone: orderData.shippingAddress.phone,
      shipping_street: orderData.shippingAddress.address,
      shipping_city: 'N/A',
      shipping_district: 'N/A',
      shipping_postal_code: null,
      notes: null,
    })
    .select()
    .single();

  if (orderError) throw orderError;

  // Create order items
  const orderItems = orderData.items.map((item) => ({
    order_id: order.id,
    product_id: item.product.id,
    product_name: item.product.name,
    product_image: item.product.images[0],
    price: item.product.price,
    quantity: item.quantity,
  }));

  const { error: itemsError } = await supabase
    .from('order_items')
    .insert(orderItems);

  if (itemsError) throw itemsError;

  // Update product stock
  for (const item of orderData.items) {
    await supabase
      .from('products')
      .update({ stock: item.product.stock - item.quantity })
      .eq('id', item.product.id);
  }

  return {
    id: order.id,
    userId: order.user_id || '',
    items: orderData.items,
    total: total,
    subtotal: subtotal,
    shipping: shippingCost,
    status: order.status as Order['status'],
    paymentMethod: order.payment_method as Order['paymentMethod'],
    paymentStatus: order.payment_status as Order['paymentStatus'],
    shippingAddress: {
      id: '',
      name: order.shipping_name,
      phone: order.shipping_phone,
      street: order.shipping_street,
      city: order.shipping_city,
      district: order.shipping_district,
      postalCode: order.shipping_postal_code || '',
    },
    createdAt: order.created_at,
    updatedAt: order.updated_at,
  };
};

export const fetchUserOrders = async (userId: string): Promise<Order[]> => {
  const { data, error } = await supabase
    .from('orders')
    .select(`
      *,
      order_items (*)
    `)
    .eq('user_id', userId)
    .order('created_at', { ascending: false });

  if (error) throw error;

  return (data || []).map((order): Order => ({
    id: order.id,
    userId: order.user_id || '',
    items: (order.order_items || []).map((item: any) => ({
      product: {
        id: item.product_id,
        name: item.product_name,
        slug: '',
        description: '',
        price: Number(item.price),
        images: [item.product_image],
        category: '',
        rating: 0,
        reviewCount: 0,
        stock: 0,
      },
      quantity: item.quantity,
    })),
    total: Number(order.total),
    subtotal: Number(order.subtotal),
    shipping: Number(order.shipping_cost),
    discount: Number(order.discount) || undefined,
    status: order.status as Order['status'],
    paymentMethod: order.payment_method as Order['paymentMethod'],
    paymentStatus: order.payment_status as Order['paymentStatus'],
    shippingAddress: {
      id: '',
      name: order.shipping_name,
      phone: order.shipping_phone,
      street: order.shipping_street,
      city: order.shipping_city,
      district: order.shipping_district,
      postalCode: order.shipping_postal_code || '',
    },
    createdAt: order.created_at,
    updatedAt: order.updated_at,
    trackingNumber: order.tracking_number || undefined,
  }));
};
